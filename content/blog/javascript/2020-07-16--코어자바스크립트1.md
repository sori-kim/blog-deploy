---
title: '[JavaScript] 코어자바스크립트 1장. 데이터 타입 '
date: 2020-07-26 05:12:03
draft: false
category: 'javascript'
---

## 데이터 타입의 종류

![Presentation20](https://user-images.githubusercontent.com/60246689/88475177-9f09f600-cf68-11ea-9c15-c62e5408d999.jpg)

자바스크립트에서 데이터 타입은 크게 `기본형`과 `참조형`으로 나누어진다.
이 둘의 가장 큰 차이는 기본형은 담긴 주솟값을 바로 복사하는 반면 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복사한다는 점이다. (어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 하기 때문에, 엄밀히 말하면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수밖에 없다. 다만 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한단계를 더 거치게 된다.)

이 차이로 인해 기본형은 불변성을 띄고 참조형은 가변성을 띈다.

이 부분에 대해 이해를 하기 위해서는 컴퓨터에서 메모리를 어떻게 할당하고 처리하는지에 대한 원리를 간단하게나마 알고 있어야한다.

## 변수 선언과 할당 시 컴퓨터에서 일어나는 일

[참고] 변수는 변경 가능한 데이터가 담길 수 있는 공간이고, 식별자는 그 변수의 이름을 말한다.

#### 기본형 데이터의 할당

변수를 선언하면 컴퓨터는 우선 메모리의 빈 공간에 식별자를 저장하고, 그 공간의 값은 undefined를 할당한다. 이후 그 변수에 기본형 데이터를 할당하려고 하면 별도의 공간에 데이터를 저장하고, 그 공간의 주소를 변수의 값 영역에 할당한다.

#### 참조형 데이터의 할당

참조형 데이터를 할당하고자 할 경우, 컴퓨터는 참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 별도로 확보해서 확보된 주소를 변수에 연결한다. 다시 앞서 확보한 변수 영역에 각 프로퍼티의 식별자를 저장하고 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭시킨다.

이처럼 할당 과정에서 기본형과 차이가 생긴 이유는 참조형 데이터가 여러 개의 프로퍼티(변수)를 모은 '그룹'이기 때문이다. 그리고 이 차이로 인해 참조형 데이터를 '가변값'으로 여겨야만 하는 상황이 발생한다. 이 부분에 대한 이야기는 추후에 더 자세하게 알아보자.

## 불변 객체를 만드는 방법

바로 위에서 언급했듯이 참조형 데이터의 '가변'은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립한다.
데이터 자체를 변경하고자 하면 (새로운 데이터를 할당하고자 하면) 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않는다.
그렇다면 내부 프로퍼티를 변경할 필요가 있을때마다 매번 새로운 객체를 만들어 할당하기로 규칙을 정하거나, 새로운 객체를 만드는 도구를 활용한다면 객체 역시 불변성을 확보할 수 있을 것이다.

그럼 어떤 상황에서 불변 객체가 필요할까?
값으로 전달 받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우가 종종 발생한다. 바로 이럴때 불변 객체가 필요하다.

객체의 가변성으로 인한 문제의 예시는 다음과 같은 상황이다.

```jsx
var user = {
  name: 'sori',
  gener: 'female',
}

var changeName = function(user, newName) {
  var newUser = user
  newUser.name = newName
  return newUser
}

var user2 = changeName(user, 'rosie')

if (user !== user2) {
  console.log('유저 정보가 변경되었습니다.')
}

console.log(user.name, user2.name) // 'sori'. 'rosie'
console.log(user === user2) //true
```

newUser라는 새로운 변수에 user 객체를 복사한 뒤, 이름을 변경하는 코드를 작성했다.  
결과를 콘솔에 출력해보니 newUser에 새로운 이름을 입력하자 기존 객체인 user의 name 역시 변경된 것을 알 수 있다.
그 이유는 객체 자체를 복사하면 그 객체를 가리키는 주솟값을 복사하는 것이고 데이터 영역은 동일하다.
그래서 이 문제를 해결하는 방법은 변경 전과 후에 서로 다른 객체를 바라보게 만드는 것이다.

```jsx
var user = {
  name: 'sori',
  gener: 'female',
}

var changeName = function(user, newName) {
  return {
    name: newName,
    genter: user.gender,
  }
}

var user2 = changeName(user, 'rosie')

if (user !== user2) {
  console.log('유저 정보가 변경되었습니다.')
} // '유저 정보가 변경되었습니다'

console.log(user.name, user2.name) //'sori'. 'rosie'
console.log(user === user2) // false
```

changeName 함수가 새로운 객체를 반환하도록 수정했다.
